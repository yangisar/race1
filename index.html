<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>DAYINBALL VERTICAL</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Permanent+Marker&family=Rubik+Glitch&display=swap');

        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #111;
            font-family: 'Permanent Marker', cursive, sans-serif;
            touch-action: none; /* Prevents scroll/zoom */
            user-select: none;
            -webkit-user-select: none;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            background: #000;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* HUD & UI */
        #hud-top {
            position: absolute;
            top: 26%; /* Just below the skyline */
            left: 0;
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 5px 15px;
            box-sizing: border-box;
            z-index: 10;
            font-size: 1.2rem;
            color: #FFF;
            text-shadow: 2px 2px #000;
            background: linear-gradient(to bottom, rgba(0,0,0,0.8), rgba(0,0,0,0));
            pointer-events: none;
        }

        .bar-container {
            width: 100px;
            height: 15px;
            background: #333;
            border: 2px solid #FFF;
            margin-top: 5px;
            transform: skewX(-15deg);
        }
        .bar-fill {
            height: 100%;
            background: #00FF00;
            width: 100%;
            transition: width 0.2s, background 0.2s;
        }

        /* Overlays */
        .overlay {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.92);
            color: #FFD700;
            z-index: 20;
            text-align: center;
        }

        h1 {
            font-family: 'Rubik Glitch', cursive;
            font-size: 3.5rem;
            margin: 0;
            color: #FFF;
            text-shadow: 4px 4px #FF0000;
            transform: rotate(-2deg);
            line-height: 1;
        }

        .btn-start {
            margin-top: 40px;
            padding: 20px 60px;
            font-size: 1.5rem;
            font-family: 'Permanent Marker', cursive;
            background-color: #FF0000;
            color: #FFF;
            border: 3px solid #FFF;
            cursor: pointer;
            box-shadow: 0px 0px 20px #FF0000;
            text-transform: uppercase;
            border-radius: 5px;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.05); } 100% { transform: scale(1); } }

        /* Controls Area */
        #controls-area {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 25vh;
            z-index: 15;
            display: flex;
            justify-content: space-around; /* simple L/R split */
            align-items: center;
        }

        .touch-zone {
            width: 30%;
            height: 80%;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 15px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 50px;
            color: rgba(255,255,255,0.7);
        }
        .touch-zone:active { background: rgba(255,0,0,0.3); border-color: red; color: white; }

        #screen-start { display: flex; }
        #screen-gameover { display: none; }

    </style>
</head>
<body>

    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>

        <div id="hud-top">
            <div>
                HP
                <div class="bar-container"><div id="healthBar" class="bar-fill"></div></div>
            </div>
            <div style="text-align: right;">
                <span id="scoreVal" style="color:#FFD700; font-size: 1.5rem;">0</span><br>
                <span id="speedVal" style="font-size: 0.8rem; color:#aaa;">0 KM/H</span>
            </div>
        </div>

        <div id="screen-start" class="overlay">
            <h1>DAYINBALL<br>VERTICAL</h1>
            <p style="color:#ccc; margin-top:20px;">AVOID TRAFFIC.<br>COLLECT LETTERS.<br>GRAB FLASKS.</p>
            <button class="btn-start" onclick="initGame()">DRIVE</button>
        </div>

        <div id="screen-gameover" class="overlay">
            <h1 style="color: #FF0000;">CRASHED</h1>
            <p style="font-size: 1.5rem;">Score: <span id="end-score">0</span></p>
            <p style="font-size: 1rem; color: #00FF00; max-width: 80%; word-wrap: break-word;" id="end-collection"></p>
            <button class="btn-start" onclick="resetGame()">RETRY</button>
        </div>

        <div id="controls-area">
            <div class="touch-zone" id="btn-left">◀</div>
            <div class="touch-zone" id="btn-brake" style="height: 50%; width: 20%; font-size: 30px;">▼</div>
            <div class="touch-zone" id="btn-right">▶</div>
        </div>
    </div>

    <script>
        // --- Audio System ---
        const AudioEngine = {
            ctx: null, isPlaying: false, beatInterval: null,
            init: function() { if(!this.ctx) this.ctx = new (window.AudioContext||window.webkitAudioContext)(); },
            tone: function(f,t,d,v=0.1) {
                if(!this.ctx) return;
                const o=this.ctx.createOscillator(), g=this.ctx.createGain();
                o.type=t; o.frequency.setValueAtTime(f,this.ctx.currentTime);
                g.gain.setValueAtTime(v,this.ctx.currentTime);
                g.gain.exponentialRampToValueAtTime(0.01,this.ctx.currentTime+d);
                o.connect(g); g.connect(this.ctx.destination); o.start(); o.stop(this.ctx.currentTime+d);
            },
            noise: function(d,v=0.2) {
                if(!this.ctx) return;
                const b=this.ctx.createBuffer(1,this.ctx.sampleRate*d,this.ctx.sampleRate), dt=b.getChannelData(0);
                for(let i=0;i<dt.length;i++) dt[i]=Math.random()*2-1;
                const s=this.ctx.createBufferSource(), g=this.ctx.createGain();
                s.buffer=b; g.gain.setValueAtTime(v,this.ctx.currentTime);
                g.gain.exponentialRampToValueAtTime(0.01,this.ctx.currentTime+d);
                s.connect(g); g.connect(this.ctx.destination); s.start();
            },
            crash: function() { this.noise(0.5,0.4); this.tone(60,'sawtooth',0.5,0.3); },
            collect: function() { this.tone(1000,'sine',0.1); setTimeout(()=>this.tone(1500,'sine',0.1),100); },
            heal: function() { this.tone(400,'sine',0.2); this.tone(600,'sine',0.4); },
            beat: function() {
                if(this.isPlaying) return; this.isPlaying=true; let c=0;
                this.beatInterval = setInterval(()=>{
                    if(c===0||c===4) { // Kick
                        const o=this.ctx.createOscillator(), g=this.ctx.createGain();
                        o.freq=100; g.gain=0.5; o.connect(g); g.connect(this.ctx.destination);
                        o.start(); o.stop(this.ctx.currentTime+0.1);
                    }
                    if(c===2||c===6) this.noise(0.1, 0.15); // Snare
                    if(c%1===0) this.noise(0.02, 0.05); // Hat
                    c=(c+1)%8;
                }, 140);
            },
            stop: function() { clearInterval(this.beatInterval); this.isPlaying=false; }
        };

        // --- Game Setup ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Config
        const HORIZON_PCT = 0.25; // Top 25% is sky/city
        let horizonY;
        let roadWidth;
        
        // State
        let gameState = 'START';
        let frames = 0;
        let speed = 0;
        let baseSpeed = 5;
        let score = 0;
        let collectedStr = "";
        const kazakhChars = ['А', 'Ә', 'Б', 'В', 'Ғ', 'Д', 'Е', 'Ж', 'З', 'И', 'К', 'Қ', 'Л', 'М', 'Н', 'Ң', 'О', 'Ө', 'П', 'Р', 'С', 'Т', 'У', 'Ұ', 'Ү', 'Ф', 'Х', 'Һ', 'Ш', 'Ы', 'І'];

        // Car (Top Down)
        const car = {
            x: 0, y: 0, 
            w: 40, h: 80, 
            health: 100,
            lane: 1, // 0, 1, 2, 3
            targetX: 0
        };

        // Objects
        let entities = []; // Combined obstacles, letters, flasks
        let particles = [];
        let roadOffset = 0;

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            horizonY = canvas.height * HORIZON_PCT;
            roadWidth = canvas.width; 
            
            // Initial Car Pos
            car.y = canvas.height - 120;
            car.w = canvas.width * 0.12; // dynamic width
            car.h = car.w * 2.2;
            car.targetX = canvas.width / 2 - car.w/2;
            car.x = car.targetX;
        }
        window.addEventListener('resize', resize);
        resize();

        // --- Input ---
        const keys = { left: false, right: false, brake: false };
        
        // Touch Handlers
        const btnL = document.getElementById('btn-left');
        const btnR = document.getElementById('btn-right');
        const btnB = document.getElementById('btn-brake');

        const handleInput = (key, state) => {
            if(state && !keys[key]) {
                // On press logic
            }
            keys[key] = state;
        };

        btnL.addEventListener('touchstart', (e)=>{ e.preventDefault(); keys.left=true; });
        btnL.addEventListener('touchend', (e)=>{ e.preventDefault(); keys.left=false; });
        btnR.addEventListener('touchstart', (e)=>{ e.preventDefault(); keys.right=true; });
        btnR.addEventListener('touchend', (e)=>{ e.preventDefault(); keys.right=false; });
        btnB.addEventListener('touchstart', (e)=>{ e.preventDefault(); keys.brake=true; });
        btnB.addEventListener('touchend', (e)=>{ e.preventDefault(); keys.brake=false; });

        // Keyboard
        window.addEventListener('keydown', e=>{
            if(e.key==='ArrowLeft'||e.key==='a') keys.left=true;
            if(e.key==='ArrowRight'||e.key==='d') keys.right=true;
            if(e.key==='ArrowDown'||e.key==='s') keys.brake=true;
        });
        window.addEventListener('keyup', e=>{
            if(e.key==='ArrowLeft'||e.key==='a') keys.left=false;
            if(e.key==='ArrowRight'||e.key==='d') keys.right=false;
            if(e.key==='ArrowDown'||e.key==='s') keys.brake=false;
        });

        // --- Drawing ---

        function drawSkyline() {
            // 1. Sky Gradient
            let grad = ctx.createLinearGradient(0, 0, 0, horizonY);
            grad.addColorStop(0, '#000033');
            grad.addColorStop(1, '#4B0082'); // Indigo
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, canvas.width, horizonY);

            // 2. Mountains (Alatau)
            ctx.fillStyle = '#C0C0C0'; // Snowy peaks
            ctx.beginPath();
            ctx.moveTo(0, horizonY);
            // Jagged peaks
            for(let i=0; i<=canvas.width; i+=20) {
                let h = Math.random() * 30 + 30;
                ctx.lineTo(i, horizonY - h);
            }
            ctx.lineTo(canvas.width, horizonY);
            ctx.fill();

            // 3. Buildings (City Skyline)
            ctx.fillStyle = '#111';
            let bw = 30;
            for(let i=0; i<canvas.width; i+=bw) {
                let h = Math.random() * 40 + 10;
                ctx.fillRect(i, horizonY - h, bw+2, h);
                // Windows
                ctx.fillStyle = '#FFFF00';
                if(Math.random()>0.8) ctx.fillRect(i+5, horizonY-h+5, 4, 4);
                ctx.fillStyle = '#111';
            }

            // 4. Kok Tobe Hill & Tower (Right side)
            let hillX = canvas.width * 0.75;
            // Hill
            ctx.fillStyle = '#0a2a0a'; // Dark green
            ctx.beginPath();
            ctx.arc(hillX, horizonY + 20, 60, 0, Math.PI, true);
            ctx.fill();
            // Tower
            ctx.strokeStyle = '#888';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(hillX, horizonY - 40); // Base
            ctx.lineTo(hillX, horizonY - 120); // Top
            ctx.stroke();
            // The Apple/Bead
            ctx.fillStyle = '#AA0000';
            ctx.beginPath(); ctx.arc(hillX, horizonY - 100, 6, 0, Math.PI*2); ctx.fill();
            // Antenna
            ctx.strokeStyle = '#fff'; ctx.lineWidth=1;
            ctx.beginPath(); ctx.moveTo(hillX, horizonY-120); ctx.lineTo(hillX, horizonY-140); ctx.stroke();
        }

        function drawRoad() {
            // Road Surface
            ctx.fillStyle = '#222';
            ctx.fillRect(0, horizonY, canvas.width, canvas.height - horizonY);

            // Grass/Shoulders
            ctx.fillStyle = '#1b2b1b';
            ctx.fillRect(0, horizonY, 15, canvas.height-horizonY);
            ctx.fillRect(canvas.width-15, horizonY, 15, canvas.height-horizonY);

            // Moving Lanes
            ctx.fillStyle = '#FFF';
            let numLanes = 4;
            let laneW = canvas.width / numLanes;
            
            ctx.save();
            ctx.beginPath();
            // Clip to road area
            ctx.rect(0, horizonY, canvas.width, canvas.height-horizonY);
            ctx.clip();

            for(let l=1; l<numLanes; l++) {
                let lineX = l * laneW;
                for(let y = -100; y < canvas.height; y+=80) {
                    let drawY = y + (roadOffset % 80);
                    if(drawY > horizonY) {
                        ctx.fillRect(lineX - 2, drawY, 4, 40);
                    }
                }
            }
            ctx.restore();
        }

        function drawCar() {
            const {x, y, w, h} = car;
            
            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.fillRect(x+10, y+10, w, h);

            // Body (Lincoln Top Down - Long Rectangle)
            ctx.fillStyle = '#000'; // Black Paint
            // Main Chassis
            roundRect(ctx, x, y, w, h, 4);
            ctx.fill();

            // Hood (Front is Up in logic, but visually car drives UP, so Hood is top)
            // Wait, standard vertical runners: Objects move DOWN, Car faces UP.
            // So Front of car is Top (lower Y value).
            
            // Hood
            ctx.fillStyle = '#111';
            ctx.fillRect(x+2, y+2, w-4, h*0.35);

            // Roof
            ctx.fillStyle = '#050505';
            ctx.fillRect(x+2, y+h*0.35, w-4, h*0.3);

            // Trunk
            ctx.fillStyle = '#111';
            ctx.fillRect(x+2, y+h*0.65, w-4, h*0.33);

            // Windshield (Front)
            ctx.fillStyle = '#444'; // Tinted
            ctx.fillRect(x+4, y+h*0.32, w-8, 4);
            // Rear Window
            ctx.fillRect(x+4, y+h*0.65, w-8, 4);

            // "DAYINBALL" Red Graffiti on Roof
            ctx.save();
            ctx.translate(x + w/2, y + h*0.5);
            ctx.rotate(-Math.PI/2); // Text runs along the length
            ctx.fillStyle = '#FF0000';
            ctx.font = 'bold 14px "Permanent Marker"';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText("DAYINBALL", 0, 0);
            ctx.restore();

            // Headlights (Top)
            ctx.fillStyle = '#FFDD00';
            ctx.fillRect(x+2, y, 8, 4);
            ctx.fillRect(x+w-10, y, 8, 4);
            
            // Taillights (Bottom)
            ctx.fillStyle = '#CC0000';
            ctx.fillRect(x+2, y+h-4, w-4, 4);
        }

        function drawEntities() {
            entities.forEach(e => {
                // e.y is the top of the object
                if(e.y > horizonY - e.h && e.y < canvas.height) {
                    
                    if(e.type === 'obstacle') {
                        // Draw Obstacle (Top Down Block)
                        ctx.fillStyle = e.color;
                        ctx.fillRect(e.x, e.y, e.w, e.h);
                        // 3D effect
                        ctx.fillStyle = 'rgba(0,0,0,0.3)';
                        ctx.fillRect(e.x, e.y+e.h, e.w, 5); // Shadow
                        
                        // Detail
                        ctx.fillStyle = '#000';
                        if(e.shape === 'barricade') {
                            ctx.fillRect(e.x+5, e.y, 5, e.h);
                            ctx.fillRect(e.x+e.w-10, e.y, 5, e.h);
                        }
                    } 
                    else if (e.type === 'letter') {
                        // Draw Letter (Circle)
                        ctx.fillStyle = '#FFD700'; // Gold
                        ctx.beginPath();
                        ctx.arc(e.x + e.w/2, e.y + e.h/2, e.w/2, 0, Math.PI*2);
                        ctx.fill();
                        ctx.lineWidth = 2; ctx.strokeStyle = '#000'; ctx.stroke();
                        
                        ctx.fillStyle = '#000';
                        ctx.font = 'bold 24px Arial';
                        ctx.textAlign = 'center'; ctx.textBaseline='middle';
                        ctx.fillText(e.char, e.x+e.w/2, e.y+e.h/2);
                    }
                    else if (e.type === 'flask') {
                        // Draw Health Flask (Blue + White Stripe + G)
                        // Body
                        ctx.fillStyle = '#0000FF'; // Blue
                        roundRect(ctx, e.x, e.y, e.w, e.h, 5);
                        ctx.fill();
                        
                        // White Stripe
                        ctx.fillStyle = '#FFFFFF';
                        ctx.fillRect(e.x, e.y + e.h*0.3, e.w, e.h*0.4);
                        
                        // Letter G
                        ctx.fillStyle = '#FF0000'; // Red G
                        ctx.font = 'bold 20px Arial';
                        ctx.textAlign = 'center'; ctx.textBaseline='middle';
                        ctx.fillText("G", e.x + e.w/2, e.y + e.h/2);
                        
                        // Cap
                        ctx.fillStyle = '#444';
                        ctx.fillRect(e.x + e.w*0.3, e.y - 5, e.w*0.4, 5);
                    }
                }
            });
        }

        function drawParticles() {
            particles.forEach((p, i) => {
                ctx.fillStyle = p.c;
                ctx.fillRect(p.x, p.y, p.s, p.s);
                p.x += p.vx; p.y += p.vy;
                p.l -= 0.05;
                if(p.l <= 0) particles.splice(i, 1);
            });
        }

        // Helper
        function roundRect(ctx, x, y, w, h, r) {
            ctx.beginPath();
            ctx.moveTo(x + r, y);
            ctx.lineTo(x + w - r, y);
            ctx.quadraticCurveTo(x + w, y, x + w, y + r);
            ctx.lineTo(x + w, y + h - r);
            ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
            ctx.lineTo(x + r, y + h);
            ctx.quadraticCurveTo(x, y + h, x, y + h - r);
            ctx.lineTo(x, y + r);
            ctx.quadraticCurveTo(x, y, x + r, y);
            ctx.closePath();
        }

        // --- Logic ---

        function update() {
            // Speed logic
            if(keys.brake && baseSpeed > 2) baseSpeed -= 0.1;
            else if (baseSpeed < 15) baseSpeed += 0.005; // Gradual accel
            
            speed = baseSpeed;
            roadOffset += speed * 3;

            // Car Movement (Horizontal)
            let moveSpeed = 6;
            if(keys.left && car.x > 0) car.x -= moveSpeed;
            if(keys.right && car.x < canvas.width - car.w) car.x += moveSpeed;

            // Spawning
            // Spawns start at horizonY and move DOWN (increase Y)
            let spawnRate = Math.max(20, 60 - Math.floor(baseSpeed * 2));
            
            if(frames % spawnRate === 0) {
                let r = Math.random();
                let lane = Math.floor(Math.random() * 4); // 4 lanes
                let laneW = canvas.width / 4;
                // Center in lane
                let spawnX = (lane * laneW) + (laneW/2) - 20; 
                let spawnY = horizonY - 50; // Start just above horizon

                if(r < 0.6) {
                    // Obstacle
                    let type = Math.random() > 0.5 ? 'barricade' : 'block';
                    let c = type === 'barricade' ? '#FF4500' : '#777';
                    entities.push({
                        type: 'obstacle', shape: type,
                        x: spawnX, y: spawnY, w: 40, h: 40, color: c, active: true
                    });
                } else if (r < 0.9) {
                    // Letter
                    let char = kazakhChars[Math.floor(Math.random()*kazakhChars.length)];
                    entities.push({
                        type: 'letter', char: char,
                        x: spawnX, y: spawnY, w: 40, h: 40, active: true
                    });
                } else {
                    // Health Flask
                    entities.push({
                        type: 'flask',
                        x: spawnX, y: spawnY, w: 30, h: 40, active: true
                    });
                }
            }

            // Move Entities
            entities.forEach(e => {
                e.y += speed;
                // Slight perspective scale? For simple arcade feel, constant size is fine.
            });

            // Cleanup
            entities = entities.filter(e => e.y < canvas.height + 50 && e.active);

            // Collisions
            checkCollisions();

            // HUD
            document.getElementById('healthBar').style.width = car.health + '%';
            if(car.health<30) document.getElementById('healthBar').style.background='red';
            else document.getElementById('healthBar').style.background='#00FF00';
            
            document.getElementById('scoreVal').innerText = score;
            document.getElementById('speedVal').innerText = Math.floor(baseSpeed * 12) + " KM/H";

            frames++;
            if(car.health <= 0) gameOver();
        }

        function checkCollisions() {
            entities.forEach(e => {
                // AABB Collision
                if(car.x < e.x + e.w && car.x + car.w > e.x &&
                   car.y < e.y + e.h && car.y + car.h > e.y) {
                    
                    if(e.active) {
                        if(e.type === 'obstacle') {
                            car.health -= 20;
                            AudioEngine.crash();
                            // Explosion
                            for(let i=0;i<10;i++) particles.push({
                                x:e.x+e.w/2, y:e.y+e.h/2, vx:(Math.random()-0.5)*10, vy:(Math.random()-0.5)*10, s:5, l:1, c:'#FF4500'
                            });
                        }
                        else if (e.type === 'letter') {
                            score++;
                            collectedStr += e.char + " ";
                            AudioEngine.collect();
                        }
                        else if (e.type === 'flask') {
                            car.health = Math.min(100, car.health + 20);
                            AudioEngine.heal();
                        }
                        e.active = false;
                    }
                }
            });
        }

        // --- Loop ---
        function loop() {
            if(gameState !== 'PLAYING') return;

            ctx.clearRect(0,0,canvas.width,canvas.height);
            
            drawSkyline(); // Top section
            drawRoad();    // Bottom section
            drawEntities(); // Objects on road
            drawParticles();
            drawCar();      // Player

            update();
            requestAnimationFrame(loop);
        }

        function initGame() { AudioEngine.init(); startGame(); }
        
        function startGame() {
            document.getElementById('screen-start').style.display='none';
            document.getElementById('screen-gameover').style.display='none';
            document.getElementById('hud-top').style.display='flex';
            
            gameState='PLAYING';
            score=0; car.health=100; baseSpeed=5; entities=[]; particles=[]; collectedStr="";
            
            resize(); // Reset positions
            AudioEngine.beat();
            loop();
        }

        function gameOver() {
            gameState='GAMEOVER';
            AudioEngine.stop();
            document.getElementById('screen-gameover').style.display='flex';
            document.getElementById('end-score').innerText = score;
            document.getElementById('end-collection').innerText = collectedStr;
        }

        function resetGame() { startGame(); }

    </script>
</body>
</html>
