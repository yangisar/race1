<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>DAYINBALL 3D VIEW</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Permanent+Marker&family=Rubik+Glitch&display=swap');

        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Permanent Marker', cursive, sans-serif;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            background: #000;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* --- UI LAYER --- */
        #ui-layer {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none; /* Let touches pass through to controls */
            z-index: 10;
        }

        /* HUD */
        .hud-bar {
            position: absolute;
            top: 25%; /* Just under horizon */
            left: 10px;
            right: 10px;
            display: flex;
            justify-content: space-between;
            color: #fff;
            text-shadow: 1px 1px 0 #000;
            font-size: 1rem;
        }
        
        .health-wrap {
            display: flex; align-items: center; gap: 5px;
        }
        .hp-bar {
            width: 80px; height: 10px;
            background: #333; border: 1px solid #fff;
            transform: skewX(-15deg);
        }
        .hp-fill {
            width: 100%; height: 100%; background: #00FF00;
            transition: width 0.2s;
        }

        /* OVERLAYS */
        .overlay {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 50;
            pointer-events: auto;
            color: #FFD700;
        }
        
        h1 {
            font-family: 'Rubik Glitch', cursive;
            font-size: 3rem; margin: 0;
            color: #FFF; text-shadow: 3px 3px #FF0000;
            transform: rotate(-3deg);
        }

        .btn-action {
            margin-top: 20px;
            padding: 15px 40px;
            font-size: 1.2rem;
            font-family: 'Permanent Marker', cursive;
            background: #FF0000; color: #FFF;
            border: 2px solid #FFF;
            box-shadow: 0 0 10px #FF0000;
            text-transform: uppercase;
        }

        /* --- CONTROLS --- */
        /* Placed physically on top, but visually subtle */
        #controls-layer {
            position: absolute;
            bottom: 20px; left: 0;
            width: 100%; height: 180px;
            z-index: 20;
            display: flex;
            justify-content: space-between;
            padding: 0 20px;
            box-sizing: border-box;
        }

        .dpad {
            position: relative;
            width: 140px; height: 140px;
            background: rgba(255, 255, 255, 0.05); /* Very low opacity */
            border-radius: 50%;
            border: 1px solid rgba(255,255,255,0.1);
        }

        /* Invisible touch targets */
        .btn-zone {
            position: absolute;
            background: rgba(255,0,0,0.0); /* Invisible but clickable */
        }
        /* Visual guides (arrows) */
        .btn-visual {
            position: absolute;
            color: rgba(255,255,255,0.2); /* Faint */
            font-size: 24px;
            pointer-events: none;
        }

        /* D-Pad Positioning */
        #btn-u { top: 0; left: 33%; width: 33%; height: 33%; }
        #btn-d { bottom: 0; left: 33%; width: 33%; height: 33%; }
        #btn-l { top: 33%; left: 0; width: 33%; height: 33%; }
        #btn-r { top: 33%; right: 0; width: 33%; height: 33%; }
        
        /* Visual Arrow Positions */
        .arr-u { top: 5px; left: 50%; transform: translateX(-50%); }
        .arr-d { bottom: 5px; left: 50%; transform: translateX(-50%); }
        .arr-l { top: 50%; left: 10px; transform: translateY(-50%); }
        .arr-r { top: 50%; right: 10px; transform: translateY(-50%); }

        /* Action/Brake Button (Right Side) */
        .brake-btn {
            width: 80px; height: 80px;
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 50%;
            margin-top: 30px; /* Align somewhat with dpad */
            display: flex; justify-content: center; align-items: center;
            color: rgba(255,255,255,0.2);
            font-size: 1rem;
        }

        .active-touch { background: rgba(255,255,255,0.1); }

    </style>
</head>
<body>

    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>

        <div id="ui-layer">
            <div class="hud-bar">
                <div class="health-wrap">
                    <span>HP</span>
                    <div class="hp-bar"><div id="hpFill" class="hp-fill"></div></div>
                </div>
                <div>SCORE: <span id="scoreVal" style="color:#FFD700">0</span></div>
            </div>
        </div>

        <div id="screen-start" class="overlay">
            <h1>DAYINBALL</h1>
            <p style="font-size:1.2rem; color:#ccc; margin-bottom: 5px;">PERSPECTIVE RUSH</p>
            <p style="font-size:0.9rem; color:#888;">GATHER 'G' FLASKS & LETTERS</p>
            <button class="btn-action" onclick="initGame()">IGNITION</button>
        </div>

        <div id="screen-gameover" class="overlay" style="display:none;">
            <h1 style="color:#FF0000">WRECKED</h1>
            <p>LETTERS: <span id="end-collection" style="color:#fff"></span></p>
            <button class="btn-action" onclick="initGame()">RESTART</button>
        </div>

        <div id="controls-layer">
            <div class="dpad">
                <div class="btn-visual arr-u">▲</div>
                <div class="btn-visual arr-d">▼</div>
                <div class="btn-visual arr-l">◀</div>
                <div class="btn-visual arr-r">▶</div>

                <div id="ctrl-up" class="btn-zone" style="top:0; left:30%; width:40%; height:35%;"></div>
                <div id="ctrl-down" class="btn-zone" style="bottom:0; left:30%; width:40%; height:35%;"></div>
                <div id="ctrl-left" class="btn-zone" style="top:30%; left:0; width:35%; height:40%;"></div>
                <div id="ctrl-right" class="btn-zone" style="top:30%; right:0; width:35%; height:40%;"></div>
            </div>
            
            <div id="ctrl-brake" class="brake-btn">BRAKE</div>
        </div>
    </div>

    <script>
        /** AUDIO SYSTEM **/
        const AudioSys = {
            ctx: null,
            init: function() { if(!this.ctx) this.ctx=new(window.AudioContext||window.webkitAudioContext)(); },
            play: function(freq, type, dur, vol=0.1) {
                if(!this.ctx) return;
                const o=this.ctx.createOscillator(), g=this.ctx.createGain();
                o.type=type; o.freq=freq; 
                o.frequency.setValueAtTime(freq, this.ctx.currentTime);
                g.gain.setValueAtTime(vol, this.ctx.currentTime);
                g.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime+dur);
                o.connect(g); g.connect(this.ctx.destination);
                o.start(); o.stop(this.ctx.currentTime+dur);
            },
            noise: function(dur) {
                if(!this.ctx) return;
                const b=this.ctx.createBuffer(1,44100*dur,44100), d=b.getChannelData(0);
                for(let i=0;i<d.length;i++) d[i]=Math.random()*2-1;
                const s=this.ctx.createBufferSource(), g=this.ctx.createGain();
                s.buffer=b; g.gain.value=0.2; g.gain.exponentialRampToValueAtTime(0.01,this.ctx.currentTime+dur);
                s.connect(g); g.connect(this.ctx.destination); s.start();
            }
        };

        /** GAME ENGINE **/
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        let gameState = 'START';
        let frames = 0;
        let score = 0;
        let collected = "";
        
        // PERSPECTIVE SETTINGS
        // Horizon line at 25% height
        let horizonY, roadBottom;
        let roadTopW, roadBottomW;
        
        // GAMEPLAY VARS
        let speed = 0;
        let baseSpeed = 4;
        const keys = { u:false, d:false, l:false, r:false, b:false };

        // Entities
        const car = { x: 0, y: 0, w: 0, h: 0, health: 100 };
        let objects = []; // Obstacles, Letters, Flasks
        let particles = [];
        let roadMarks = [];

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            horizonY = canvas.height * 0.25;
            roadBottom = canvas.height;
            
            // Trapezoid Geometry
            roadTopW = canvas.width * 0.1; // Narrow at top
            roadBottomW = canvas.width * 1.2; // Wide at bottom
            
            // Initial Car Position (Center bottom)
            car.x = 0; // -1 to 1 logic
            car.y = 0.8; // 0 to 1 logic (1 is bottom)
        }
        window.addEventListener('resize', resize);
        resize();

        // --- INPUT HANDLERS ---
        const bindTouch = (id, key) => {
            const el = document.getElementById(id);
            el.addEventListener('touchstart', (e)=>{ e.preventDefault(); keys[key]=true; el.classList.add('active-touch'); });
            el.addEventListener('touchend', (e)=>{ e.preventDefault(); keys[key]=false; el.classList.remove('active-touch'); });
            // Mouse fallbacks
            el.addEventListener('mousedown', ()=>{ keys[key]=true; });
            el.addEventListener('mouseup', ()=>{ keys[key]=false; });
        };
        bindTouch('ctrl-up', 'u');
        bindTouch('ctrl-down', 'd');
        bindTouch('ctrl-left', 'l');
        bindTouch('ctrl-right', 'r');
        bindTouch('ctrl-brake', 'b');

        window.addEventListener('keydown', e=>{
            if(e.key==='w'||e.key==='ArrowUp') keys.u=true;
            if(e.key==='s'||e.key==='ArrowDown') keys.d=true;
            if(e.key==='a'||e.key==='ArrowLeft') keys.l=true;
            if(e.key==='d'||e.key==='ArrowRight') keys.r=true;
        });
        window.addEventListener('keyup', e=>{
            if(e.key==='w'||e.key==='ArrowUp') keys.u=false;
            if(e.key==='s'||e.key==='ArrowDown') keys.d=false;
            if(e.key==='a'||e.key==='ArrowLeft') keys.l=false;
            if(e.key==='d'||e.key==='ArrowRight') keys.r=false;
        });

        // --- PERSPECTIVE MATH ---
        function getProjected(objX, objY, baseW, baseH) {
            // objX: -1 (left edge) to 1 (right edge)
            // objY: 0 (horizon) to 1 (bottom)
            
            // Scale factor based on Y (linear for simple arcade feel)
            // Horizon scale: 0.1, Bottom scale: 1.0
            const scale = 0.1 + (0.9 * objY);
            
            // Y Screen Position
            const screenY = horizonY + (objY * (roadBottom - horizonY));
            
            // Road Width at this Y
            const currentRoadW = roadTopW + (objY * (roadBottomW - roadTopW));
            
            // X Screen Position
            // Center of screen + (Offset * (CurrentRoadWidth/2))
            const screenX = (canvas.width / 2) + (objX * (currentRoadW / 2));
            
            return {
                x: screenX,
                y: screenY,
                w: baseW * scale,
                h: baseH * scale,
                s: scale
            };
        }

        // --- SPAWNERS ---
        function spawnObject() {
            const lane = (Math.random() * 2) - 1; // -1 to 1
            const typeR = Math.random();
            let type = 'obs';
            
            if(typeR > 0.7) type = 'letter';
            if(typeR > 0.95) type = 'flask';
            
            objects.push({
                x: lane,
                y: 0, // Starts at horizon
                type: type,
                char: type==='letter'? "АӘБВГҒДЕЖЗИКҚЛМНҢОӨПРСТУҰҮФХҺЦЧШЩЪЫІЬЭЮЯ"[Math.floor(Math.random()*42)] : null,
                active: true
            });
        }

        function update() {
            // SPEED
            if(keys.b) baseSpeed = Math.max(0, baseSpeed - 0.2);
            else if(baseSpeed < 10) baseSpeed += 0.01;
            speed = baseSpeed * 0.002; // Normalized speed

            // CAR MOVEMENT (Logic Space: X[-1,1], Y[0,1])
            if(keys.l && car.x > -1) car.x -= 0.03;
            if(keys.r && car.x < 1) car.x += 0.03;
            if(keys.u && car.y > 0.1) car.y -= 0.02; // Move up towards horizon
            if(keys.d && car.y < 1) car.y += 0.02;   // Move down towards screen

            // ROAD MARKS
            roadMarks.push({ y: 0, type: 'dash' }); // Spawn at top
            roadMarks.forEach(m => m.y += speed);
            roadMarks = roadMarks.filter(m => m.y < 1.1);

            // OBJECTS
            if(Math.random() < 0.03 + (baseSpeed*0.002)) spawnObject();
            
            objects.forEach(o => o.y += speed);
            objects = objects.filter(o => o.y < 1.2 && o.active);

            // COLLISIONS
            // Simple distance check in normalized space
            objects.forEach(o => {
                // Determine if 'close' enough to hit
                // Car Logic Y vs Object Logic Y
                if(Math.abs(o.y - car.y) < 0.05 && Math.abs(o.x - car.x) < 0.15) {
                    if(o.active) {
                        o.active = false;
                        if(o.type === 'obs') {
                            car.health -= 20;
                            AudioSys.noise(0.2);
                            spawnParticles(o);
                        } else if(o.type === 'letter') {
                            score++; collected += o.char;
                            AudioSys.play(1000, 'sine', 0.1);
                        } else if(o.type === 'flask') {
                            car.health = Math.min(100, car.health+20);
                            AudioSys.play(600, 'square', 0.2);
                        }
                    }
                }
            });

            // UI
            document.getElementById('hpFill').style.width = Math.max(0, car.health) + '%';
            document.getElementById('hpFill').style.background = car.health < 30 ? 'red' : '#00FF00';
            document.getElementById('scoreVal').innerText = score;

            if(car.health <= 0) gameOver();
        }

        function spawnParticles(obj) {
            // Get screen coords for explosion
            const proj = getProjected(obj.x, obj.y, 10, 10);
            for(let i=0; i<8; i++) {
                particles.push({
                    x: proj.x, y: proj.y,
                    vx: (Math.random()-0.5)*10, vy: (Math.random()-0.5)*10,
                    life: 1.0, color: '#FF4500'
                });
            }
        }

        // --- RENDER ---
        function draw() {
            if(gameState !== 'PLAYING') return;
            ctx.clearRect(0,0,canvas.width,canvas.height);

            // 1. BACKGROUND (Skyline)
            let grad = ctx.createLinearGradient(0,0,0,horizonY);
            grad.addColorStop(0, '#111'); grad.addColorStop(1, '#333');
            ctx.fillStyle = grad; ctx.fillRect(0,0,canvas.width, horizonY);
            
            // Mountains
            ctx.fillStyle = '#222';
            ctx.beginPath(); ctx.moveTo(0, horizonY);
            for(let i=0; i<=canvas.width; i+=30) ctx.lineTo(i, horizonY - Math.random()*30 - 10);
            ctx.lineTo(canvas.width, horizonY); ctx.fill();

            // TV Tower Hill
            ctx.fillStyle = '#1a1a1a';
            ctx.beginPath(); ctx.arc(canvas.width*0.7, horizonY+20, 80, 0, Math.PI, true); ctx.fill();
            // Tower
            ctx.strokeStyle = '#555'; ctx.lineWidth=2;
            ctx.beginPath(); ctx.moveTo(canvas.width*0.7, horizonY); ctx.lineTo(canvas.width*0.7, horizonY-100); ctx.stroke();
            ctx.fillStyle='#900'; ctx.beginPath(); ctx.arc(canvas.width*0.7, horizonY-80, 4, 0, 6.28); ctx.fill();

            // 2. ROAD (Trapezoid)
            ctx.fillStyle = '#222';
            ctx.beginPath();
            const topLeft = (canvas.width/2) - (roadTopW/2);
            const topRight = (canvas.width/2) + (roadTopW/2);
            const botLeft = (canvas.width/2) - (roadBottomW/2);
            const botRight = (canvas.width/2) + (roadBottomW/2);
            
            ctx.moveTo(topLeft, horizonY);
            ctx.lineTo(topRight, horizonY);
            ctx.lineTo(botRight, roadBottom);
            ctx.lineTo(botLeft, roadBottom);
            ctx.fill();

            // 3. ROAD MARKS (Yellow)
            ctx.fillStyle = '#FFD700'; // Proper Yellow
            roadMarks.forEach(m => {
                // Center Line
                // Only draw if on screen (0 to 1)
                if(m.y >= 0 && m.y <= 1) {
                    const p = getProjected(0, m.y, 10, 40); // Base sizes
                    ctx.fillRect(p.x - p.w/2, p.y, p.w, p.h);
                }
                // Side lines
                if(m.y >= 0 && m.y <= 1) {
                    const pL = getProjected(-0.95, m.y, 5, 40);
                    const pR = getProjected(0.95, m.y, 5, 40);
                    ctx.fillRect(pL.x, pL.y, pL.w, pL.h);
                    ctx.fillRect(pR.x, pR.y, pR.w, pR.h);
                }
            });

            // 4. OBJECTS (Sorted by Y so closer ones draw on top)
            // But also, car needs to be sorted with them.
            // Let's draw objects behind car if o.y < car.y, else front.
            // Actually, simple Painter's algo: Sort all entities by Y.
            
            let drawList = [...objects];
            // Add car to draw list as a proxy object
            drawList.push({ type:'car', y: car.y, x: car.x });
            
            drawList.sort((a,b) => a.y - b.y);

            drawList.forEach(obj => {
                if(obj.y < 0) return;

                // Base Dimensions (World Size) -> Reduced Scale
                let baseW = 100, baseH = 80; // Standard block size
                
                if(obj.type === 'car') {
                    // Car is smaller now
                    baseW = 80; baseH = 140; 
                    const p = getProjected(obj.x, obj.y, baseW, baseH);
                    drawCarSprite(p.x, p.y, p.w, p.h);
                } else {
                    const p = getProjected(obj.x, obj.y, baseW, baseH);
                    if(obj.type === 'obs') drawObstacle(p.x, p.y, p.w, p.h);
                    if(obj.type === 'letter') drawLetter(p.x, p.y, p.w, p.h, obj.char);
                    if(obj.type === 'flask') drawFlask(p.x, p.y, p.w, p.h);
                }
            });

            // 5. PARTICLES
            particles.forEach((p,i) => {
                ctx.fillStyle = p.color;
                ctx.fillRect(p.x, p.y, 5, 5);
                p.x += p.vx; p.y += p.vy; p.life -= 0.1;
                if(p.life <=0) particles.splice(i,1);
            });

            update();
            requestAnimationFrame(draw);
        }

        // --- SPRITE DRAWING ---
        function drawCarSprite(x, y, w, h) {
            // x,y is center bottom anchor roughly? 
            // getProjected returns center X. Let's adjust to top-left
            const cx = x - w/2;
            const cy = y - h; // Stand up

            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.6)';
            ctx.fillRect(cx+5, cy+h-5, w-10, 5);

            // Body Black
            ctx.fillStyle = '#000';
            ctx.fillRect(cx, cy + h*0.2, w, h*0.6); // Main body
            ctx.fillRect(cx + w*0.1, cy, w*0.8, h*0.2); // Roof/Cabin
            
            // Red Tag
            ctx.fillStyle = 'red';
            ctx.font = 'bold 10px Arial';
            ctx.fillText('DAYIN', cx + 2, cy + h*0.5);

            // Lights
            ctx.fillStyle = '#FFFF00'; // Headlights
            ctx.fillRect(cx+2, cy+h*0.3, 5, 5);
            ctx.fillRect(cx+w-7, cy+h*0.3, 5, 5);
            
            ctx.fillStyle = '#CC0000'; // Tail
            ctx.fillRect(cx, cy+h*0.7, w, 5);
        }

        function drawObstacle(x, y, w, h) {
            const cx = x - w/2; const cy = y - h;
            ctx.fillStyle = '#FF4500';
            ctx.fillRect(cx, cy, w, h);
            ctx.strokeStyle = '#000'; ctx.strokeRect(cx, cy, w, h);
            // Stripes
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(cx+w, cy+h); ctx.lineTo(cx+w-10, cy+h); ctx.lineTo(cx, cy+10); ctx.fill();
        }

        function drawLetter(x, y, w, h, char) {
            const cx = x - w/2; const cy = y - h;
            ctx.fillStyle = '#FFD700';
            ctx.beginPath(); ctx.arc(x, cy + h/2, w/2, 0, 6.28); ctx.fill();
            ctx.fillStyle = '#000';
            ctx.font = 'bold '+Math.floor(h*0.6)+'px Arial';
            ctx.textAlign = 'center'; ctx.textBaseline='middle';
            ctx.fillText(char, x, cy + h/2);
        }

        function drawFlask(x, y, w, h) {
            const cx = x - w/2; const cy = y - h;
            // Bottle Blue
            ctx.fillStyle = '#0000FF';
            ctx.fillRect(cx, cy + h*0.2, w, h*0.8);
            ctx.fillRect(cx + w*0.3, cy, w*0.4, h*0.2); // Neck
            
            // White Stripe
            ctx.fillStyle = '#FFF';
            ctx.fillRect(cx, cy + h*0.4, w, h*0.3);
            
            // Red G
            ctx.fillStyle = 'red';
            ctx.font = 'bold '+Math.floor(h*0.4)+'px Arial';
            ctx.textAlign = 'center'; ctx.textBaseline='middle';
            ctx.fillText("G", x, cy + h*0.55);
        }

        // --- FLOW ---
        function initGame() {
            AudioSys.init();
            document.getElementById('screen-start').style.display = 'none';
            document.getElementById('screen-gameover').style.display = 'none';
            gameState = 'PLAYING';
            score = 0; collected = "";
            car.health = 100; car.x=0; car.y=0.8;
            objects = []; particles = []; roadMarks = [];
            baseSpeed = 4;
            draw();
        }
        
        function gameOver() {
            gameState = 'OVER';
            document.getElementById('screen-gameover').style.display = 'flex';
            document.getElementById('end-collection').innerText = collected;
        }

    </script>
</body>
</html>
